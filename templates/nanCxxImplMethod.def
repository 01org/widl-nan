{{ var className = "Nan" + it.name; }}

{{~ it.members :p:i }}
{{? p.type === 'operation' }}

{{#def.methodOverload}}

{{
  var generateMethod = isFirstMethodInOverloadList(it, p, i);
  var overloadList = it.operationMap[p.name];

  var methodName = p.name;
  var methodOverloadList = [];
  overloadList.forEach(o => {
    methodOverloadList.push(it.members[o.index]);
  });
}}

{{? generateMethod}}

NAN_METHOD({{=className}}::{{=methodName}}) {
  // Nan::HandleScope scope;
  auto myself = ObjectWrap::Unwrap<{{=className}}>(info.Holder());

  info.GetReturnValue().Set(Nan::Undefined());

{{~ methodOverloadList :method:index}}
{{
  var numArgs = method.arguments.length;
  var elseIf = '';
  if (index > 0) {
    elseIf = 'else ';
  }
}}

  {{=elseIf}}if (info.Length() == {{=numArgs}}) {
    // Method: name = {{=method.name}}, taking {{=numArgs}} argument(s)

{{ var argStr = ""; }}
{{~ method.arguments :q:j}}

{{
  argStr += "arg" + j;
  if (j<method.arguments.length-1) {
    argStr += ', ';
  }
}}
    auto arg{{=j}} = EXTRACT_v8_{{=q.idlType.idlType}}(info[{{=j}}]);
{{~}}

{{? method.idlType.generic === 'Promise' }}
    // Return promise
    auto promise = myself->impl_->{{=methodName}}({{=argStr}}, info.GetIsolate());
    info.GetReturnValue().Set(promise);
{{?? method.idlType.idlType === 'void' }}
    // Return type is void
    myself->impl_->{{=methodName}}({{=argStr}});
    info.GetReturnValue().Set(Nan::Undefined());
{{?? method.idlType.idlType === 'String' }}
    // Return type is string
    auto value = myself->impl_->{{=methodName}}({{=argStr}});
    info.GetReturnValue().Set(Nan::New(value).ToLocalChecked());
{{?? true }}
    // Primitive types (int, double ...)
    auto value = myself->impl_->{{=methodName}}({{=argStr}});
    info.GetReturnValue().Set(Nan::New(value));
{{?}}

  } // Closing bracket of 'if (info.Length() == {{=numArgs}})'

{{~}}

}

{{?}}

{{?}}

{{~}}
