{{ var className = "Nan" + it.name; }}

{{#def.idlType}}
{{#def.buildValidEnumValuesList}}
{{#def.enum}}
{{#def.extractV8Value}}
{{#def.callback}}
{{#def.overload}}


{{
var callback = extractAllCallbackMethod(it);
var hasCallback = callback.methods.length > 0;
}}



{{~ it.members :p:i }}
{{? p.type === 'operation' }}

{{
  var generateMethod = isFirstMethodInOverloadList(it, p, i);
  var overloadList = it.operationMap[p.name];

  var methodName = p.name;
  var methodOverloadList = [];
  overloadList.forEach(o => {
    methodOverloadList.push(it.members[o.index]);
  });
}}

{{? generateMethod}}

NAN_METHOD({{=className}}::{{=methodName}}) {
  // Nan::HandleScope scope;
  auto myself = ObjectWrap::Unwrap<{{=className}}>(info.Holder());

  info.GetReturnValue().Set(Nan::Undefined());

{{~ methodOverloadList :method:index}}
{{
  var numArgs = method.arguments.length;
  var elseIf = '';
  if (index > 0) {
    elseIf = 'else ';
  }
}}

  {{=elseIf}}if (info.Length() == {{=numArgs}} && ({{=generateArgsIfConditionStr(method, it.refTypeMap, callback)}})) {
    // Method: name = {{=method.name}}, taking {{=numArgs}} argument(s)

{{ var argStr = ""; }}
{{~ method.arguments :q:j}}

{{
  argStr += "arg" + j;
  if (j<method.arguments.length-1) {
    argStr += ', ';
  }
}}

{{? isCallback(q.idlType, callback) }}
{{var callbackHelperClassName = getCallbackHelperClassName(q.idlType.idlType);}}
    auto function{{=j}} = {{=extractArgument(q.idlType, it.refTypeMap, callback)}}(info[{{=j}}]);
    {{=callbackHelperClassName}}* arg{{=j}} = new {{=callbackHelperClassName}}();
    arg{{=j}}->Reset(function{{=j}}, info.This());
{{?? true}}
    auto arg{{=j}} = {{=extractArgument(q.idlType, it.refTypeMap)}}(info[{{=j}}]);
{{?}}


{{
  var enumCheck = isEnumType(q.idlType, it.refTypeMap);
  var enumDef = getEnumDef(q.idlType, it.refTypeMap);
  var enumName = enumDef.name;
}}

{{? enumCheck }}
    // Valid enum values for parameter info{{=j}}, original IDL type: {{=enumName}}
    const char* VALID_ENUM_{{=(enumName.toUpperCase())}}_INFO{{=j}}[] = { {{=buildValidEnumValuesList(enumDef)}} };
    ThrowIfEnumValueNotValid(arg{{=j}}, VALID_ENUM_{{=(enumName.toUpperCase())}}_INFO{{=j}}, {{=q.name}}, {{=enumName}});
{{?}}

{{~}}




{{? method.idlType.generic === 'Promise' }}
    // Return promise
    auto promise = myself->impl_->{{=methodName}}({{=argStr}}, info.GetIsolate());
    info.GetReturnValue().Set(promise);
{{?? method.idlType.idlType === 'void' }}
    // Return type is void
    myself->impl_->{{=methodName}}({{=argStr}});
    info.GetReturnValue().Set(Nan::Undefined());
{{?? method.idlType.idlType === 'String' || method.idlType.idlType === 'DOMString' }}
    // Return type is string
    auto value = myself->impl_->{{=methodName}}({{=argStr}});
    info.GetReturnValue().Set(Nan::New(value).ToLocalChecked());
{{?? true }}
    // Primitive types (int, double ...)
    auto value = myself->impl_->{{=methodName}}({{=argStr}});
    info.GetReturnValue().Set(Nan::New(value));
{{?}}

  } // Closing bracket of 'if (info.Length() == {{=numArgs}})'

{{~}}

  else {
    // TODO: handle no-match by modifying template nanCxxImplMethod.def
  }
}

{{?}}

{{?}}

{{~}}
