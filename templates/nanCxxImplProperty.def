{{ var className = "Nan" + it.name; }}

{{#def.idlType}}
{{#def.enum}}
{{#def.impl}}
{{#def.interface}}
{{#def.dictionary}}
{{#def.returnType}}
{{#def.buildValidEnumValuesList}}
{{#def.extractV8Value}}

{{~ it.members :p:i }}
{{? p.type === 'attribute' }}

{{
  var str = getToLocalCheckedString(p.idlType, it.refTypeMap);
}}

NAN_GETTER({{=className}}::{{=p.name}}Getter) {
  auto myself = ObjectWrap::Unwrap<{{=className}}>(info.Holder());
  auto impl_val = myself->impl_->get_{{=p.name}}();

{{
  var enumCheck = isEnumType(p.idlType, it.refTypeMap);
  var enumDef = getEnumDef(p.idlType, it.refTypeMap);
  var enumName = enumDef.name;
}}

{{? enumCheck }}
  // Valid enum values for parameter info{{=j}}, original IDL type: {{=enumName}}
  const char* VALID_ENUM_{{=(enumName.toUpperCase())}}_INFO[] = { {{=buildValidEnumValuesList(enumDef)}} };
  if (IsEnumValueValid(impl_val, VALID_ENUM_{{=(enumName.toUpperCase())}}_INFO)) {
    info.GetReturnValue().Set(Nan::New(impl_val){{=str}});
  } else {
    // TODO: modify nanCxxImplProperty.def to handle this case
  }
{{?? isInterface(p.idlType, it.refTypeMap)}}
  // Returns an object to JavaScript
{{ var retType = p.idlType.idlType; }}
    auto value = Nan{{=retType}}::NewInstance();
    ObjectWrap::Unwrap<Nan{{=retType}}>(value)->Copy{{=retType}}Impl(impl_val);
  info.GetReturnValue().Set(value);
{{?? isDictionary(p.idlType, it.refTypeMap)}}
  info.GetReturnValue().Set(static_cast<v8::Local<v8::Object>>(impl_val));
{{?? true}}
  info.GetReturnValue().Set(Nan::New(impl_val){{=str}});
{{?}}

}

{{? ! p.readonly }}
NAN_SETTER({{=className}}::{{=p.name}}Setter) {
  auto myself = ObjectWrap::Unwrap<{{=className}}>(info.Holder());
  auto v8_value = {{=extractArgument(p.idlType, it.refTypeMap)}}(value);

{{
  var enumCheck = isEnumType(p.idlType, it.refTypeMap);
  var enumDef = getEnumDef(p.idlType, it.refTypeMap);
  var enumName = enumDef.name;
}}

{{? enumCheck }}
  // Valid enum values for parameter info{{=j}}, original IDL type: {{=enumName}}
  const char* VALID_ENUM_{{=(enumName.toUpperCase())}}_INFO[] = { {{=buildValidEnumValuesList(enumDef)}} };
  if (IsEnumValueValid(v8_value, VALID_ENUM_{{=(enumName.toUpperCase())}}_INFO)) {
    myself->impl_->set_{{=p.name}}(v8_value);
  } else {
    // TODO: modify nanCxxImplProperty.def to handle this case
  }
{{?? isInterface(p.idlType, it.refTypeMap)}}
  // Extract data from the JavaScript object
  // First, convert to impl {{=p.idlType.idlType}} pointer
  auto impl_value = *(ObjectWrap::Unwrap<Nan{{=p.idlType.idlType}}>(v8_value)->{{=generateGetImplMethodName(p.idlType.idlType)}}());
  myself->impl_->set_{{=p.name}}(impl_value);
{{?? true}}
  myself->impl_->set_{{=p.name}}(v8_value);
{{?}}

}
{{?}}

{{?}}
{{~}}
