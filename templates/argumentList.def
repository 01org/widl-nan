{{#def.idlType2CxxConversion}}
{{#def.enum}}
{{#def.buildValidEnumValuesList}}
{{#def.extractV8Value}}

{{~ p.arguments :q:j }}
      auto {{=q.name}} = {{=extractArgument(q.idlType, it.refTypeMap)}}(info[{{=j}}]);
{{
  var enumCheck = isEnumType(q.idlType, it.refTypeMap);
  var enumDef = getEnumDef(q.idlType, it.refTypeMap);
  var enumName = enumDef.name;
}}

{{? enumCheck }}
      // Valid enum values for parameter info{{=j}}, original IDL type: {{=enumName}}
      const char* VALID_ENUM_{{=(enumName.toUpperCase())}}_INFO[] = { {{=buildValidEnumValuesList(enumDef)}} };
      if (!IsEnumValueValid({{=q.name}}, VALID_ENUM_{{=(enumName.toUpperCase())}}_INFO)) {
        // TODO: modify argumentList.def to handle this case
        std::string err = "Illegal argument: ";
        err += "{{=enumName}}";
        err += " ";
        err += "{{=q.name}}";
        err += " == ";
        err += "'";
        err += {{=q.name}};
        err += "'";
        Nan::ThrowTypeError(err.c_str());
      }
{{?}}

{{~}}
